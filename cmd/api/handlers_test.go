package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"testing"

	"github.com/PlayEconomy37/Play.Common/filters"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

func TestHealthCheckHandler(t *testing.T) {
	app, cleanup, _ := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	statusCode, _, resBody := ts.get(t, "/healthcheck", false, "")

	if statusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, statusCode)
	}

	if !bytes.Contains(resBody, []byte("available")) {
		t.Errorf("want body %q to contain %q", []byte("available"), resBody)
	}
}

func TestGetInventoryItemsHandler(t *testing.T) {
	app, cleanup, catalogItemIDs := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Seed inventory items collection
	seedInventoryItemsCollection(t, ts, app.InventoryItemsRepository, catalogItemIDs)

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has catalog:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, "/items", tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	validationTests := []struct {
		testName           string
		queryString        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No user_id set", "", http.StatusUnprocessableEntity, []byte("must be greater than 0")},
		{"Invalid user id (below 1)", "?user_id=-1", http.StatusUnprocessableEntity, []byte("must be greater than 0")},
		{"Invalid page", "?page=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid page_size", "?page_size=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid sort value", "?sort=invalid", http.StatusUnprocessableEntity, []byte("invalid sort value")},
		{"page lower than 0", "?page=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page greater than 10000000", "?page=10000001", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page_size lower than 0", "?page_size=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
		{"page_size greater than 100", "?page_size=101", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items%s", tt.queryString), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	successTests := []struct {
		testName             string
		queryString          string
		wantedStatusCode     int
		expectedTotalRecords int
		expectedCurrentPage  int
		expectedLastPage     int
	}{
		{"user_id, page and page_size filters (page 1)", "?user_id=1&page=1&page_size=2", http.StatusOK, 2, 1, 2},
		{"user_id, page and page_size filters (page 2)", "?user_id=1&page=2&page_size=2", http.StatusOK, 1, 2, 2},
		{"user_id and sort filters", "?user_id=1&sort=-quantity", http.StatusOK, 3, 1, 1},
	}

	for _, tt := range successTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items%s", tt.queryString), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			var jsonRes map[string]any

			err := json.Unmarshal(resBody, &jsonRes)
			if err != nil {
				t.Error("Failed to parse json response")
			}

			items := (jsonRes["items"]).([]any)

			if tt.testName == "user_id and sort filters" {
				item0 := (items[0]).(map[string]any)
				if item0["name"] != "Antidote" {
					t.Errorf("want to receive Antidote but got %s", item0["name"])
				}

				item1 := (items[1]).(map[string]any)
				if item1["name"] != "Ether" {
					t.Errorf("want to receive Ether but got %s", item1["name"])
				}

				item2 := (items[2]).(map[string]any)
				if item2["name"] != "Potion" {
					t.Errorf("want to receive Potion but got %s", item2["name"])
				}
			}

			if len(items) != tt.expectedTotalRecords {
				t.Errorf("want to receive %d items but got %d", tt.expectedTotalRecords, len(items))
			}

			metadata := (jsonRes["metadata"]).(map[string]any)

			if metadata["total_records"] == tt.expectedTotalRecords {
				t.Errorf("want total_records to be %d but got %d", tt.expectedTotalRecords, metadata["total_records"])
			}

			if metadata["current_page"] == tt.expectedCurrentPage {
				t.Errorf("want current_page to be %d but got %d", tt.expectedCurrentPage, metadata["current_page"])
			}

			if metadata["last_page"] == tt.expectedLastPage {
				t.Errorf("want last_page to be %d but got %d", tt.expectedLastPage, metadata["last_page"])
			}
		})
	}
}

func TestGrantItemsHandler(t *testing.T) {
	app, cleanup, catalogItemIDs := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has inventory:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
		{"User does not have permission - has catalog:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["userID"] = 1
			body["catalogItemID"] = catalogItemIDs[0]
			body["quantity"] = 2

			statusCode, _, resBody := ts.post(t, "/items", body, tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	tests := []struct {
		testName           string
		userID             int64
		catalogItemID      primitive.ObjectID
		quantity           int64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", 1, catalogItemIDs[0], 2, http.StatusOK, []byte("Item granted successfully")},
		{"Invalid user id (below 1)", 0, catalogItemIDs[0], 2, http.StatusUnprocessableEntity, []byte("must be greater than 0")},
		{"Invalid quantity (below 1)", 1, catalogItemIDs[0], 0, http.StatusUnprocessableEntity, []byte("must be greater than 0")},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["userID"] = tt.userID
			body["catalogItemID"] = tt.catalogItemID
			body["quantity"] = tt.quantity

			statusCode, _, resBody := ts.post(t, "/items", body, true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// Check if inventory item was created successfully
	inventoryItems, _, err := app.InventoryItemsRepository.GetAll(context.Background(), bson.M{}, filters.Filters{Page: 1, PageSize: 20, Sort: "_id", SortSafelist: []string{"_id", "name"}})
	if err != nil {
		t.Fatal(err)
	}

	if len(inventoryItems) != 1 {
		t.Errorf("want inventoryItems to contain 1 item, but got %d", len(inventoryItems))
	}

	if inventoryItems[0].Quantity != 2 {
		t.Errorf("want quantity to be 2, but got %d", inventoryItems[0].Quantity)
	}

	// -----------------------------

	updateItemTest := struct {
		testName           string
		userID             int64
		catalogItemID      primitive.ObjectID
		quantity           int64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Valid update",
		1,
		catalogItemIDs[0],
		3,
		http.StatusOK,
		[]byte("Item granted successfully"),
	}

	body := map[string]any{}
	body["userID"] = updateItemTest.userID
	body["catalogItemID"] = updateItemTest.catalogItemID
	body["quantity"] = updateItemTest.quantity

	statusCode, _, resBody := ts.post(t, "/items", body, true, accessTokenUser1)

	if statusCode != updateItemTest.wantedStatusCode {
		t.Errorf("want %d; got %d", updateItemTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, updateItemTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, updateItemTest.wantedResponseBody)
	}

	// Check if inventory item was created successfully
	refetchedInventoryItems, _, err := app.InventoryItemsRepository.GetAll(context.Background(), bson.M{}, filters.Filters{Page: 1, PageSize: 20, Sort: "_id", SortSafelist: []string{"_id", "name"}})
	if err != nil {
		t.Fatal(err)
	}

	if len(refetchedInventoryItems) != 1 {
		t.Errorf("want refetchedInventoryItems to contain 1 item, but got %d", len(refetchedInventoryItems))
	}

	if refetchedInventoryItems[0].Quantity != 5 {
		t.Errorf("want quantity to be 5, but got %d", refetchedInventoryItems[0].Quantity)
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		userID             int64
		catalogItemID      primitive.ObjectID
		quantity           string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		1,
		catalogItemIDs[0],
		"invalid",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body = map[string]any{}
	body["userID"] = malformedJSONTest.userID
	body["catalogItemID"] = malformedJSONTest.catalogItemID
	body["quantity"] = malformedJSONTest.quantity

	statusCode, _, resBody = ts.post(t, "/items", body, true, accessTokenUser1)

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		userID             int64
		catalogItemID      primitive.ObjectID
		invalid            int64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		1,
		catalogItemIDs[0],
		2,
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["userID"] = unknownKeyTest.userID
	body["catalogItemID"] = unknownKeyTest.catalogItemID
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.post(t, "/items", body, true, accessTokenUser1)

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}
}
